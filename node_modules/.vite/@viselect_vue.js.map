{
  "version": 3,
  "sources": ["../@viselect/vanilla/src/utils/css.ts", "../@viselect/vanilla/src/utils/events.ts", "../@viselect/vanilla/src/utils/intersects.ts", "../@viselect/vanilla/src/utils/removeElement.ts", "../@viselect/vanilla/src/utils/selectAll.ts", "../@viselect/vanilla/src/utils/constants.ts", "../@viselect/vanilla/src/utils/deep-assign.ts", "../@viselect/vanilla/src/index.ts", "../@viselect/vanilla/src/EventEmitter.ts", "../@viselect/vue/src/SelectionArea.vue", "../@viselect/vue/src/SelectionArea.vue?vue&type=template&id=a2740ee0&lang.js", "dep:@viselect_vue"],
  "sourcesContent": ["/* eslint-disable @typescript-eslint/no-explicit-any */\r\nimport type {Properties} from 'csstype';\r\n\r\nconst unitify = (val: string | number, unit = 'px'): string => {\r\n    return typeof val === 'number' ? val + unit : val;\r\n};\r\n\r\n/**\r\n * Add css to a DOM-Element or returns the current\r\n * value of a property.\r\n *\r\n * @param el The Element.\r\n * @param attr The attribute or a object which holds css key-properties.\r\n * @param val The value for a single attribute.\r\n * @returns {*}\r\n */\r\nexport function css(\r\n    {style}: HTMLElement,\r\n    attr: Partial<Record<keyof Properties, string | number>> | keyof Properties,\r\n    val?: string | number\r\n): void {\r\n    if (typeof attr === 'object') {\r\n\r\n        for (const [key, value] of Object.entries(attr)) {\r\n            style[key as any] = unitify(value as string | number);\r\n        }\r\n\r\n    } else if (val !== undefined) {\r\n        style[attr as any] = unitify(val);\r\n    }\r\n}\r\n\r\n\r\n", "/* eslint-disable @typescript-eslint/explicit-module-boundary-types */\r\n/* eslint-disable @typescript-eslint/no-explicit-any */\r\ntype Method = 'addEventListener' | 'removeEventListener';\r\ntype AnyFunction = (...arg: any) => any;\r\n\r\nexport type EventBindingArgs = [\r\n        EventTarget | Array<EventTarget>,\r\n        string | Array<string>,\r\n    AnyFunction,\r\n    Record<string, unknown>?\r\n];\r\n\r\ninterface EventBinding {\r\n    (\r\n        elements: EventTarget | Array<EventTarget>,\r\n        events: string | Array<string>,\r\n        fn: AnyFunction,\r\n        options?: Record<string, unknown>\r\n    ): EventBindingArgs;\r\n}\r\n\r\n/* eslint-disable prefer-rest-params */\r\nfunction eventListener(method: Method): EventBinding {\r\n    return (\r\n        items: EventTarget | Array<EventTarget>,\r\n        events: string | Array<string>,\r\n        fn: AnyFunction, options = {}\r\n    ): EventBindingArgs => {\r\n\r\n        // Normalize array\r\n        if (items instanceof HTMLCollection || items instanceof NodeList) {\r\n            items = Array.from(items);\r\n        } else if (!Array.isArray(items)) {\r\n            items = [items];\r\n        }\r\n\r\n        if (!Array.isArray(events)) {\r\n            events = [events];\r\n        }\r\n\r\n        for (const el of items) {\r\n            for (const ev of events) {\r\n                el[method](ev, fn as EventListener, {capture: false, ...options});\r\n            }\r\n        }\r\n\r\n        return [items, events, fn, options];\r\n    };\r\n}\r\n\r\n/**\r\n * Add event(s) to element(s).\r\n * @param elements DOM-Elements\r\n * @param events Event names\r\n * @param fn Callback\r\n * @param options Optional options\r\n * @return Array passed arguments\r\n */\r\nexport const on = eventListener('addEventListener');\r\n\r\n/**\r\n * Remove event(s) from element(s).\r\n * @param elements DOM-Elements\r\n * @param events Event names\r\n * @param fn Callback\r\n * @param options Optional options\r\n * @return Array passed arguments\r\n */\r\nexport const off = eventListener('removeEventListener');\r\n\r\n/**\r\n * Simplifies a touch / mouse-event\r\n * @param evt\r\n */\r\nexport const simplifyEvent = (evt: any): {\r\n    tap: MouseEvent | Touch;\r\n    x: number;\r\n    y: number;\r\n    target: HTMLElement;\r\n} => {\r\n    const tap = (evt.touches && evt.touches[0] || evt);\r\n    return {\r\n        tap,\r\n        x: tap.clientX,\r\n        y: tap.clientY,\r\n        target: tap.target\r\n    };\r\n};\r\n\r\n/**\r\n * Polyfill for safari & firefox for the eventPath event property.\r\n * @param evt The event object.\r\n * @return [String] event path.\r\n */\r\nexport function eventPath(evt: any): Array<EventTarget> {\r\n    let path: Array<EventTarget> = evt.path || (evt.composedPath && evt.composedPath());\r\n    if (path) {\r\n        return path;\r\n    }\r\n\r\n    let el = evt.target.parentElement;\r\n    path = [evt.target, el];\r\n\r\n    /* eslint-disable no-cond-assign */\r\n    while (el = el.parentElement) {\r\n        path.push(el);\r\n    }\r\n\r\n    path.push(document, window);\r\n    return path;\r\n}\r\n\r\n", "export type Intersection = 'center' | 'cover' | 'touch'\r\n\r\n/**\r\n * Check if two DOM-Elements intersects each other.\r\n * @param a BoundingClientRect of the first element.\r\n * @param b BoundingClientRect of the second element.\r\n * @param mode Options are center, cover or touch.\r\n * @returns {boolean} If both elements intersects each other.\r\n */\r\nexport function intersects(a: DOMRect, b: DOMRect, mode: Intersection = 'touch'): boolean {\r\n    switch (mode) {\r\n        case 'center': {\r\n            const bxc = b.left + b.width / 2;\r\n            const byc = b.top + b.height / 2;\r\n\r\n            return bxc >= a.left &&\r\n                bxc <= a.right &&\r\n                byc >= a.top &&\r\n                byc <= a.bottom;\r\n        }\r\n        case 'cover': {\r\n            return b.left >= a.left &&\r\n                b.top >= a.top &&\r\n                b.right <= a.right &&\r\n                b.bottom <= a.bottom;\r\n        }\r\n        case 'touch': {\r\n            return a.right >= b.left &&\r\n                a.left <= b.right &&\r\n                a.bottom >= b.top &&\r\n                a.top <= b.bottom;\r\n        }\r\n        default: {\r\n            throw new Error(`Unkown intersection mode: ${mode}`);\r\n        }\r\n    }\r\n}\r\n", "/**\r\n * Removes an element from an Array.\r\n */\r\nexport function removeElement<T>(arr: T[], el: T): void {\r\n    const index = arr.indexOf(el);\r\n\r\n    if (~index) {\r\n        arr.splice(index, 1);\r\n    }\r\n}\r\n", "export type SelectAllSelectors = readonly (string | Element)[] | string | Element;\r\n\r\n/**\r\n * Takes a selector (or array of selectors) and returns the matched nodes.\r\n * @param selector The selector or an Array of selectors.\r\n * @param doc\r\n * @returns {Array} Array of DOM-Nodes.\r\n */\r\nexport function selectAll(selector: SelectAllSelectors, doc: Document = document): Array<Element> {\r\n    const list = !Array.isArray(selector) ? [selector] : selector;\r\n\r\n    const nodes = [];\r\n    for (let i = 0, l = list.length; i < l; i++) {\r\n        const item = list[i];\r\n\r\n        if (typeof item === 'string') {\r\n            nodes.push(...Array.from(doc.querySelectorAll(item)));\r\n        } else if (item instanceof HTMLElement) {\r\n            nodes.push(item);\r\n        }\r\n    }\r\n\r\n    return nodes;\r\n}\r\n", "// Determines if the device's primary input supports touch\r\n// See this article: https://css-tricks.com/touch-devices-not-judged-size/\r\nexport const isTouchDevice = (): boolean => window.matchMedia('(hover: none), (pointer: coarse)').matches;\r\n", "/* eslint-disable @typescript-eslint/no-explicit-any */\r\n/* eslint-disable @typescript-eslint/explicit-module-boundary-types */\r\nexport const deepAssign = <O>(target: O, source: any): O => {\r\n    for (const [key, value] of Object.entries(target)) {\r\n        const sourceValue = source[key];\r\n\r\n        // Use the default value if there's no value specified\r\n        target[key as keyof O] = sourceValue === undefined ? target[key as keyof O] :\r\n\r\n            // Check if it's a nested object and merge if required\r\n            (typeof sourceValue === 'object' && typeof value === 'object' && value !== null && !Array.isArray(value)) ?\r\n                deepAssign(value as O, sourceValue as Partial<O>) : sourceValue;\r\n    }\r\n\r\n    return target;\r\n};\r\n", "import {EventTarget} from './EventEmitter';\r\nimport type {AreaLocation, Coordinates, ScrollEvent, SelectionEvents, SelectionOptions, SelectionStore} from './types';\r\nimport {PartialSelectionOptions} from './types';\r\nimport {css, deepAssign, eventPath, intersects, isTouchDevice, off, on, removeElement, selectAll, SelectAllSelectors, simplifyEvent} from './utils';\r\n\r\n// Re-export types\r\nexport * from './types';\r\n\r\n// Some var shorting for better compression and readability\r\nconst {abs, max, min, ceil} = Math;\r\n\r\nexport default class SelectionArea extends EventTarget<SelectionEvents> {\r\n    public static version = VERSION;\r\n\r\n    // Options\r\n    private readonly _options: SelectionOptions;\r\n\r\n    // Selection store\r\n    private _selection: SelectionStore = {\r\n        touched: [],\r\n        stored: [],\r\n        selected: [],\r\n        changed: {\r\n            added: [], // Added elements since last selection\r\n            removed: [] // Removed elements since last selection\r\n        }\r\n    };\r\n\r\n    // Area element and clipping element\r\n    private readonly _area: HTMLElement;\r\n    private readonly _clippingElement: HTMLElement;\r\n\r\n    // Target container (element) and boundary (cached)\r\n    private _targetElement?: Element;\r\n    private _targetRect?: DOMRect;\r\n    private _selectables: Array<Element> = [];\r\n\r\n    // Caches the position of the selection-area\r\n    private readonly _areaRect = new DOMRect();\r\n\r\n    // Dynamically constructed area rect\r\n    private _areaLocation: AreaLocation = {y1: 0, x2: 0, y2: 0, x1: 0};\r\n\r\n    // If a single click is being performed.\r\n    // It's a single-click until the user dragged the mouse.\r\n    private _singleClick = true;\r\n\r\n    // Is getting set on movement. Varied.\r\n    private _scrollAvailable = true;\r\n    private _scrollSpeed: Coordinates = {x: 0, y: 0};\r\n    private _scrollDelta: Coordinates = {x: 0, y: 0};\r\n\r\n    constructor(opt: PartialSelectionOptions) {\r\n        super();\r\n\r\n        this._options = deepAssign<SelectionOptions>({\r\n            selectionAreaClass: 'selection-area',\r\n            selectionContainerClass: undefined,\r\n            selectables: [],\r\n            document: window.document,\r\n\r\n            behaviour: {\r\n                overlap: 'invert',\r\n                intersect: 'touch',\r\n                startThreshold: {x: 10, y: 10},\r\n                scrolling: {\r\n                    speedDivider: 10,\r\n                    manualSpeed: 750\r\n                }\r\n            },\r\n\r\n            features: {\r\n                range: true,\r\n                touch: true,\r\n                singleTap: {\r\n                    allow: true,\r\n                    intersect: 'native'\r\n                }\r\n            },\r\n\r\n            startAreas: ['html'],\r\n            boundaries: ['html'],\r\n            container: 'body'\r\n        }, opt);\r\n\r\n        // Bind locale functions to instance\r\n        /* eslint-disable @typescript-eslint/no-explicit-any */\r\n        for (const key of Object.getOwnPropertyNames(Object.getPrototypeOf(this))) {\r\n            if (typeof (this as any)[key] === 'function') {\r\n                (this as any)[key] = (this as any)[key].bind(this);\r\n            }\r\n        }\r\n\r\n        const {document, selectionAreaClass, selectionContainerClass} = this._options;\r\n        this._area = document.createElement('div');\r\n        this._clippingElement = document.createElement('div');\r\n        this._clippingElement.appendChild(this._area);\r\n\r\n        // Add class to the area element\r\n        this._area.classList.add(selectionAreaClass);\r\n        selectionContainerClass && this._clippingElement.classList.add(selectionContainerClass);\r\n\r\n        // Apply basic styles to the area element\r\n        css(this._area, {\r\n            willChange: 'top, left, bottom, right, width, height',\r\n            top: 0,\r\n            left: 0,\r\n            position: 'fixed'\r\n        });\r\n\r\n        css(this._clippingElement, {\r\n            overflow: 'hidden',\r\n            position: 'fixed',\r\n            transform: 'translate3d(0, 0, 0)', // https://stackoverflow.com/a/38268846\r\n            pointerEvents: 'none',\r\n            zIndex: '1'\r\n        });\r\n\r\n        this.enable();\r\n    }\r\n\r\n    _bindStartEvents(activate = true): void {\r\n        const {document, features} = this._options;\r\n        const fn = activate ? on : off;\r\n\r\n        fn(document, 'mousedown', this._onTapStart);\r\n        features.touch && fn(document, 'touchstart', this._onTapStart, {\r\n            passive: false\r\n        });\r\n    }\r\n\r\n    _onTapStart(evt: MouseEvent | TouchEvent, silent = false): void {\r\n        const {x, y, target} = simplifyEvent(evt);\r\n        const {_options} = this;\r\n        const {document} = this._options;\r\n        const targetBoundingClientRect = target.getBoundingClientRect();\r\n\r\n        // Find start-areas and boundaries\r\n        const startAreas = selectAll(_options.startAreas, _options.document);\r\n        const resolvedBoundaries = selectAll(_options.boundaries, _options.document);\r\n\r\n        // Check in which container the user currently acts\r\n        this._targetElement = resolvedBoundaries.find(el =>\r\n            intersects(el.getBoundingClientRect(), targetBoundingClientRect)\r\n        );\r\n\r\n        // Check if area starts in one of the start areas / boundaries\r\n        const evtpath = eventPath(evt);\r\n        if (!this._targetElement ||\r\n            !startAreas.find(el => evtpath.includes(el)) ||\r\n            !resolvedBoundaries.find(el => evtpath.includes(el))) {\r\n            return;\r\n        }\r\n\r\n        if (!silent && this._emitEvent('beforestart', evt) === false) {\r\n            return;\r\n        }\r\n\r\n        // Area rect\r\n        this._areaLocation = {x1: x, y1: y, x2: 0, y2: 0};\r\n\r\n        // Lock scrolling in target container\r\n        // Solution to preventing scrolling taken fr\r\n        const scrollElement = document.scrollingElement || document.body;\r\n        this._scrollDelta = {x: scrollElement.scrollLeft, y: scrollElement.scrollTop};\r\n\r\n        // To detect single-click\r\n        this._singleClick = true;\r\n        this.clearSelection(false);\r\n\r\n        // Add listener\r\n        on(document, ['touchmove', 'mousemove'], this._delayedTapMove, {passive: false});\r\n        on(document, ['mouseup', 'touchcancel', 'touchend'], this._onTapStop);\r\n        on(document, 'scroll', this._onScroll);\r\n    }\r\n\r\n    _onSingleTap(evt: MouseEvent | TouchEvent): void {\r\n        const {singleTap: {intersect}, range} = this._options.features;\r\n        const e = simplifyEvent(evt);\r\n        let target = null;\r\n\r\n        if (intersect === 'native') {\r\n            target = e.target;\r\n        } else if (intersect === 'touch') {\r\n            this.resolveSelectables();\r\n\r\n            const {x, y} = e;\r\n            target = this._selectables.find(v => {\r\n                const {right, left, top, bottom} = v.getBoundingClientRect();\r\n                return x < right && x > left && y < bottom && y > top;\r\n            });\r\n        }\r\n\r\n        if (!target) {\r\n            return;\r\n        }\r\n\r\n        /**\r\n         * Resolve selectables again.\r\n         * If the user starded in a scrollable area they will be reduced\r\n         * to the current area. Prevent the exclusion of these if a range-selection\r\n         * gets performed.\r\n         */\r\n        this.resolveSelectables();\r\n\r\n        // Traverse dom upwards to check if target is selectable\r\n        while (!this._selectables.includes(target)) {\r\n            if (!target.parentElement) {\r\n                return;\r\n            }\r\n\r\n            target = target.parentElement;\r\n        }\r\n\r\n        // Grab current store first in case it gets resetted\r\n        const {stored} = this._selection;\r\n\r\n        // Emit event and process element\r\n        this._emitEvent('start', evt);\r\n        if (evt.shiftKey && stored.length && range) {\r\n            const reference = stored[0];\r\n\r\n            // Resolve correct range\r\n            const [preceding, following] = reference.compareDocumentPosition(target) & 4 ?\r\n                [target, reference] : [reference, target];\r\n\r\n            const rangeItems = [...this._selectables.filter(el =>\r\n                (el.compareDocumentPosition(preceding) & 4) &&\r\n                (el.compareDocumentPosition(following) & 2)\r\n            ), target, preceding, following];\r\n\r\n            this.select(rangeItems);\r\n        } else if (stored.includes(target) && (stored.length === 1 || evt.ctrlKey)) {\r\n            this.deselect(target);\r\n        } else {\r\n            this.select(target);\r\n        }\r\n\r\n        this._emitEvent('stop', evt);\r\n    }\r\n\r\n    _delayedTapMove(evt: MouseEvent | TouchEvent): void {\r\n        const {container, document, features, behaviour: {startThreshold}} = this._options;\r\n        const {x1, y1} = this._areaLocation; // Coordinates of first \"tap\"\r\n        const {x, y} = simplifyEvent(evt);\r\n\r\n        // Check pixel threshold\r\n        const thresholdType = typeof startThreshold;\r\n        if (\r\n\r\n            // Single number\r\n            (thresholdType === 'number' && abs((x + y) - (x1 + y1)) >= startThreshold) ||\r\n\r\n            // Different x and y threshold\r\n            (thresholdType === 'object' && abs(x - x1) >= (startThreshold as Coordinates).x || abs(y - y1) >= (startThreshold as Coordinates).y)\r\n        ) {\r\n            off(document, ['mousemove', 'touchmove'], this._delayedTapMove, {passive: false});\r\n            on(document, ['mousemove', 'touchmove'], this._onTapMove, {passive: false});\r\n\r\n            // Make area element visible\r\n            css(this._area, 'display', 'block');\r\n\r\n            // Apppend selection-area to the dom\r\n            selectAll(container, document)[0].appendChild(this._clippingElement);\r\n\r\n            // Now after the threshold is reached resolve all selectables\r\n            this.resolveSelectables();\r\n\r\n            // An action is recognized as single-select until the user performed a mutli-selection\r\n            this._singleClick = false;\r\n\r\n            // Just saving the boundaries of this container for later\r\n            this._targetRect = this._targetElement!.getBoundingClientRect();\r\n\r\n            // Find container and check if it's scrollable\r\n            this._scrollAvailable =\r\n                this._targetElement!.scrollHeight !== this._targetElement!.clientHeight ||\r\n                this._targetElement!.scrollWidth !== this._targetElement!.clientWidth;\r\n\r\n            if (this._scrollAvailable) {\r\n\r\n                // Detect mouse scrolling\r\n                on(document, 'wheel', this._manualScroll, {passive: false});\r\n\r\n                /**\r\n                 * The selection-area will also cover other element which are\r\n                 * out of the current scrollable parent. So find all elements\r\n                 * which are in the current scrollable element. Later these are\r\n                 * the only selectables instead of all.\r\n                 */\r\n                this._selectables = this._selectables.filter(s => this._targetElement!.contains(s));\r\n            }\r\n\r\n            // Trigger recalc and fire event\r\n            this._prepareSelectionArea();\r\n            this._emitEvent('start', evt);\r\n            this._onTapMove(evt);\r\n        }\r\n\r\n        if (features.touch && isTouchDevice()) {\r\n            evt.preventDefault(); // Prevent swipe-down refresh\r\n        }\r\n    }\r\n\r\n    _prepareSelectionArea(): void {\r\n        const {_clippingElement, _targetElement, _area} = this;\r\n        const tr = this._targetRect = _targetElement!.getBoundingClientRect();\r\n\r\n        if (this._scrollAvailable) {\r\n\r\n            /**\r\n             * To clip the area, the selection area has a parent\r\n             * which has exact the same dimensions as the scrollable elemeent.\r\n             * Now if the area exeeds these boundaries it will be cropped.\r\n             */\r\n            css(_clippingElement, {\r\n                top: tr.top,\r\n                left: tr.left,\r\n                width: tr.width,\r\n                height: tr.height\r\n            });\r\n\r\n            /**\r\n             * The area element is relative to the clipping element,\r\n             * but when this is moved or transformed we need to correct\r\n             * the positions via a negative margin.\r\n             */\r\n            css(_area, {\r\n                marginTop: -tr.top,\r\n                marginLeft: -tr.left\r\n            });\r\n        } else {\r\n\r\n            /**\r\n             * Reset margin and clipping element dimensions.\r\n             */\r\n            css(_clippingElement, {\r\n                top: 0,\r\n                left: 0,\r\n                width: '100%',\r\n                height: '100%'\r\n            });\r\n\r\n            css(_area, {\r\n                marginTop: 0,\r\n                marginLeft: 0\r\n            });\r\n        }\r\n    }\r\n\r\n    _onTapMove(evt: MouseEvent | TouchEvent): void {\r\n        const {x, y} = simplifyEvent(evt);\r\n        const {_scrollSpeed, _areaLocation, _options} = this;\r\n        const {features} = _options;\r\n        const {speedDivider} = _options.behaviour.scrolling;\r\n        const scon = this._targetElement as Element;\r\n\r\n        _areaLocation.x2 = x;\r\n        _areaLocation.y2 = y;\r\n\r\n        if (this._scrollAvailable && (_scrollSpeed.y || _scrollSpeed.x)) {\r\n            const scroll = () => {\r\n                if (!_scrollSpeed.x && !_scrollSpeed.y) {\r\n                    return;\r\n                }\r\n\r\n                /**\r\n                 * If the value exeeds the scrollable area it will\r\n                 * be set to the max / min value. So change only\r\n                 */\r\n                const {scrollTop, scrollLeft} = scon;\r\n\r\n                // Reduce velocity, use ceil in both directions to scroll at least 1px per frame\r\n                if (_scrollSpeed.y) {\r\n                    scon.scrollTop += ceil(_scrollSpeed.y / speedDivider);\r\n                    _areaLocation.y1 -= scon.scrollTop - scrollTop;\r\n                }\r\n\r\n                if (_scrollSpeed.x) {\r\n                    scon.scrollLeft += ceil(_scrollSpeed.x / speedDivider);\r\n                    _areaLocation.x1 -= scon.scrollLeft - scrollLeft;\r\n                }\r\n\r\n                /**\r\n                 * We changed the start coordinates -> redraw the selectiona area\r\n                 * We changed the dimensions of the area element -> re-calc selected elements\r\n                 * The selected elements array has been changed -> fire event\r\n                 */\r\n                this._recalculateSelectionAreaRect();\r\n                this._updateElementSelection();\r\n                this._emitEvent('move', evt);\r\n                this._redrawSelectionArea();\r\n\r\n                // Keep scrolling even if the user stops to move his pointer\r\n                requestAnimationFrame(scroll);\r\n            };\r\n\r\n            // Continous scrolling\r\n            requestAnimationFrame(scroll);\r\n        } else {\r\n\r\n            /**\r\n             * Perform redraw only if scrolling is not active.\r\n             * If scrolling is active this area is getting re-dragwed by the\r\n             * anonymized scroll function.\r\n             */\r\n            this._recalculateSelectionAreaRect();\r\n            this._updateElementSelection();\r\n            this._emitEvent('move', evt);\r\n            this._redrawSelectionArea();\r\n        }\r\n\r\n        if (features.touch && isTouchDevice()) {\r\n            evt.preventDefault(); // Prevent swipe-down refresh\r\n        }\r\n    }\r\n\r\n    _onScroll(): void {\r\n        const {_scrollDelta, _options: {document}} = this;\r\n\r\n        // Resolve scrolling offsets\r\n        const {scrollTop, scrollLeft} = document.scrollingElement || document.body;\r\n\r\n        // Adjust area start location\r\n        this._areaLocation.x1 += _scrollDelta.x - scrollLeft;\r\n        this._areaLocation.y1 += _scrollDelta.y - scrollTop;\r\n        _scrollDelta.x = scrollLeft;\r\n        _scrollDelta.y = scrollTop;\r\n\r\n        // The area needs to be resetted as the target-container has changed in its position\r\n        this._prepareSelectionArea();\r\n        this._recalculateSelectionAreaRect();\r\n        this._updateElementSelection();\r\n        this._emitEvent('move', null);\r\n        this._redrawSelectionArea();\r\n    }\r\n\r\n    _manualScroll(evt: ScrollEvent): void {\r\n        const {manualSpeed} = this._options.behaviour.scrolling;\r\n\r\n        // Consistent scrolling speed on all browsers\r\n        const deltaY = evt.deltaY ? (evt.deltaY > 0 ? 1 : -1) : 0;\r\n        const deltaX = evt.deltaX ? (evt.deltaX > 0 ? 1 : -1) : 0;\r\n        this._scrollSpeed.y += deltaY * manualSpeed;\r\n        this._scrollSpeed.x += deltaX * manualSpeed;\r\n        this._onTapMove(evt);\r\n\r\n        // Prevent defaul scrolling behaviour, eg. page scrolling\r\n        evt.preventDefault();\r\n    }\r\n\r\n    _recalculateSelectionAreaRect(): void {\r\n        const {_scrollSpeed, _areaLocation, _areaRect, _targetElement, _targetRect} = this;\r\n        const {scrollTop, scrollHeight, clientHeight, scrollLeft, scrollWidth, clientWidth} = _targetElement as Element;\r\n        const brect = _targetRect as DOMRect;\r\n        const {x1, y1} = _areaLocation;\r\n        let {x2, y2} = _areaLocation;\r\n\r\n        if (x2 < brect.left) {\r\n            _scrollSpeed.x = scrollLeft ? -abs(brect.left - x2) : 0;\r\n            x2 = brect.left;\r\n        } else if (x2 > brect.right) {\r\n            _scrollSpeed.x = scrollWidth - scrollLeft - clientWidth ? abs(brect.left + brect.width - x2) : 0;\r\n            x2 = brect.right;\r\n        } else {\r\n            _scrollSpeed.x = 0;\r\n        }\r\n\r\n        if (y2 < brect.top) {\r\n            _scrollSpeed.y = scrollTop ? -abs(brect.top - y2) : 0;\r\n            y2 = brect.top;\r\n        } else if (y2 > brect.bottom) {\r\n            _scrollSpeed.y = scrollHeight - scrollTop - clientHeight ? abs(brect.top + brect.height - y2) : 0;\r\n            y2 = brect.bottom;\r\n        } else {\r\n            _scrollSpeed.y = 0;\r\n        }\r\n\r\n        const x3 = min(x1, x2);\r\n        const y3 = min(y1, y2);\r\n        const x4 = max(x1, x2);\r\n        const y4 = max(y1, y2);\r\n\r\n        _areaRect.x = x3;\r\n        _areaRect.y = y3;\r\n        _areaRect.width = x4 - x3;\r\n        _areaRect.height = y4 - y3;\r\n    }\r\n\r\n    _redrawSelectionArea(): void {\r\n        const {x, y, width, height} = this._areaRect;\r\n        const {style} = this._area;\r\n\r\n        // Using transform will make the area's borders look blurry\r\n        style.left = `${x}px`;\r\n        style.top = `${y}px`;\r\n        style.width = `${width}px`;\r\n        style.height = `${height}px`;\r\n    }\r\n\r\n    _onTapStop(evt: MouseEvent | TouchEvent | null, silent: boolean): void {\r\n        const {document, features} = this._options;\r\n        const {_singleClick} = this;\r\n\r\n        // Remove event handlers\r\n        off(document, ['mousemove', 'touchmove'], this._delayedTapMove);\r\n        off(document, ['touchmove', 'mousemove'], this._onTapMove);\r\n        off(document, ['mouseup', 'touchcancel', 'touchend'], this._onTapStop);\r\n        off(document, 'scroll', this._onScroll);\r\n\r\n        if (evt && _singleClick && features.singleTap.allow) {\r\n            this._onSingleTap(evt);\r\n        } else if (!_singleClick && !silent) {\r\n            this._updateElementSelection();\r\n            this._emitEvent('stop', evt);\r\n        }\r\n\r\n        // Reset scroll speed\r\n        this._scrollSpeed.x = 0;\r\n        this._scrollSpeed.y = 0;\r\n\r\n        // Unbind mouse scrolling listener\r\n        this._scrollAvailable && off(document, 'wheel', this._manualScroll, {passive: true});\r\n\r\n        // Remove selection-area from dom\r\n        this._clippingElement.remove();\r\n\r\n        // Hide selection area\r\n        css(this._area, 'display', 'none');\r\n        this._keepSelection();\r\n    }\r\n\r\n    _updateElementSelection(): void {\r\n        const {_selectables, _options, _selection, _areaRect} = this;\r\n        const {stored, selected, touched} = _selection;\r\n        const {intersect, overlap} = _options.behaviour;\r\n\r\n        // Update\r\n        const newlyTouched = [];\r\n        const added = [];\r\n        const removed = [];\r\n\r\n        // Itreate over the selectable elements\r\n        for (let i = 0; i < _selectables.length; i++) {\r\n            const node = _selectables[i];\r\n\r\n            // Check if area intersects element\r\n            if (intersects(_areaRect, node.getBoundingClientRect(), intersect)) {\r\n\r\n                // Check if the element wasn't present in the last selection.\r\n                if (!selected.includes(node)) {\r\n\r\n                    // Check if user wants to invert the selection for already selected elements\r\n                    if (overlap === 'invert' && stored.includes(node)) {\r\n                        removed.push(node);\r\n                        continue;\r\n                    } else {\r\n                        added.push(node);\r\n                    }\r\n                } else if (stored.includes(node) && !touched.includes(node)) {\r\n                    touched.push(node);\r\n                }\r\n\r\n                newlyTouched.push(node);\r\n            }\r\n        }\r\n\r\n        // Re-select elements which were previously stored\r\n        if (overlap === 'invert') {\r\n            added.push(...stored.filter(v => !selected.includes(v)));\r\n        }\r\n\r\n        // Check which elements where removed since last selection\r\n        for (let i = 0; i < selected.length; i++) {\r\n            const node = selected[i];\r\n\r\n            if (!newlyTouched.includes(node) && !(\r\n\r\n                // Check if user wants to keep previously selected elements, e.g.\r\n                // not make them part of the current selection as soon as they're touched.\r\n                overlap === 'keep' && stored.includes(node)\r\n            )) {\r\n                removed.push(node);\r\n            }\r\n        }\r\n\r\n        // Save\r\n        _selection.selected = newlyTouched;\r\n        _selection.changed = {added, removed};\r\n    }\r\n\r\n    _emitEvent(name: keyof SelectionEvents, evt: MouseEvent | TouchEvent | null): unknown {\r\n        return this.emit(name, {\r\n            event: evt,\r\n            store: this._selection,\r\n            selection: this\r\n        });\r\n    }\r\n\r\n    _keepSelection(): void {\r\n        const {_options, _selection} = this;\r\n        const {selected, changed, touched, stored} = _selection;\r\n\r\n        // Newly added elements\r\n        const addedElements = selected.filter(el => !stored.includes(el));\r\n\r\n        switch (_options.behaviour.overlap) {\r\n            case 'drop': {\r\n                _selection.stored = addedElements.concat(\r\n                    // Elements not touched\r\n                    stored.filter(el => !touched.includes(el))\r\n                );\r\n                break;\r\n            }\r\n            case 'invert': {\r\n                _selection.stored = addedElements.concat(\r\n                    // Elements not removed from selection\r\n                    stored.filter(el => !changed.removed.includes(el))\r\n                );\r\n                break;\r\n            }\r\n            case 'keep': {\r\n                _selection.stored = stored.concat(\r\n                    // Newly added\r\n                    selected.filter(el => !stored.includes(el))\r\n                );\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Manually triggers the start of a selection\r\n     * @param evt A MouseEvent / TouchEvent -like object\r\n     * @param silent If beforestart should be fired,\r\n     */\r\n    trigger(evt: MouseEvent | TouchEvent, silent = true): void {\r\n        this._onTapStart(evt, silent);\r\n    }\r\n\r\n    /**\r\n     * Can be used if during a selection elements have been added.\r\n     * Will update everything which can be selected.\r\n     */\r\n    resolveSelectables(): void {\r\n\r\n        // Resolve selectors\r\n        this._selectables = selectAll(this._options.selectables, this._options.document);\r\n    }\r\n\r\n    /**\r\n     * Clear the elements which where saved by 'keepSelection()'.\r\n     * @param store If the store should also get cleared\r\n     */\r\n    clearSelection(store = true): void {\r\n        this._selection = {\r\n            stored: store ? [] : this._selection.stored,\r\n            selected: [],\r\n            touched: [],\r\n            changed: {\r\n                added: [],\r\n                removed: []\r\n            }\r\n        };\r\n    }\r\n\r\n    /**\r\n     * @returns {Array} Selected elements\r\n     */\r\n    getSelection(): Array<Element> {\r\n        return this._selection.stored;\r\n    }\r\n\r\n    /**\r\n     * @returns {HTMLElement} The selection area element\r\n     */\r\n    getSelectionArea(): HTMLElement {\r\n        return this._area;\r\n    }\r\n\r\n    /**\r\n     * Cancel the current selection process.\r\n     * @param keepEvent {boolean} true to fire the onStop listener after cancel.\r\n     */\r\n    cancel(keepEvent = false): void {\r\n        this._onTapStop(null, !keepEvent);\r\n    }\r\n\r\n    /**\r\n     * Unbinds all events and removes the area-element.\r\n     */\r\n    destroy(): void {\r\n        this.cancel();\r\n        this.disable();\r\n        this._clippingElement.remove();\r\n        super.unbindAllListeners();\r\n    }\r\n\r\n    /**\r\n     * Disable the selection functinality.\r\n     */\r\n    /* eslint-disable no-invalid-this */\r\n    disable = this._bindStartEvents.bind(this, false);\r\n\r\n    /**\r\n     * Disable the selection functinality.\r\n     */\r\n    /* eslint-disable no-invalid-this */\r\n    enable = this._bindStartEvents;\r\n\r\n    /**\r\n     * Adds elements to the selection\r\n     * @param query - CSS Query, can be an array of queries\r\n     * @param quiet - If this should not trigger the move event\r\n     */\r\n    select(query: SelectAllSelectors, quiet = false): Array<Element> {\r\n        const {changed, selected, stored} = this._selection;\r\n        const elements = selectAll(query, this._options.document).filter(el =>\r\n            !selected.includes(el) &&\r\n            !stored.includes(el)\r\n        );\r\n\r\n        // Update stores\r\n        selected.push(...elements);\r\n        changed.added.push(...elements);\r\n\r\n        !quiet && this._emitEvent('move', null);\r\n        return elements;\r\n    }\r\n\r\n    /**\r\n     * Removes an particular element from the selection.\r\n     * @param el - Element to remove.\r\n     * @param quiet - If this should not trigger the move event\r\n     * @returns boolean - true if the element was successfully removed\r\n     */\r\n    deselect(el: Element, quiet = false): boolean {\r\n        const {selected, stored, changed} = this._selection;\r\n\r\n        if (\r\n            selected.includes(el) ||\r\n            stored.includes(el)\r\n        ) {\r\n            changed.removed.push(el);\r\n            removeElement(stored, el);\r\n            removeElement(selected, el);\r\n\r\n            // Fire event\r\n            !quiet && this._emitEvent('move', null);\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n}\r\n", "\r\n/* eslint-disable @typescript-eslint/no-explicit-any */\r\ntype AnyFunction = (...args: any[]) => any;\r\ntype EventMap = Record<string, AnyFunction>;\r\n\r\nexport class EventTarget<Events extends EventMap> {\r\n    private readonly _listeners = new Map<keyof Events, Set<AnyFunction>>();\r\n\r\n    public addEventListener<K extends keyof Events>(event: K, cb: Events[K]): this {\r\n        const set = this._listeners.get(event) || new Set();\r\n        this._listeners.set(event, set);\r\n        set.add(cb as AnyFunction);\r\n        return this;\r\n    }\r\n\r\n    public removeEventListener<K extends keyof Events>(event: K, cb: Events[K]): this {\r\n        this._listeners.get(event)?.delete(cb as AnyFunction);\r\n        return this;\r\n    }\r\n\r\n    public dispatchEvent<K extends keyof Events>(event: K, ...data: Parameters<Events[K]>): unknown {\r\n        let ok = true;\r\n        for (const cb of (this._listeners.get(event) || [])) {\r\n            ok = (cb(...data) !== false) && ok;\r\n        }\r\n\r\n        return ok;\r\n    }\r\n\r\n    public unbindAllListeners(): void {\r\n        this._listeners.clear();\r\n    }\r\n\r\n    // Let's also support on, off and emit like node\r\n    /* eslint-disable no-invalid-this */\r\n    public on = this.addEventListener;\r\n    public off = this.removeEventListener;\r\n    public emit = this.dispatchEvent;\r\n}\r\n", "<template>\r\n    <div ref=\"container\">\r\n        <slot/>\r\n    </div>\r\n</template>\r\n\r\n<script lang=\"ts\">\r\nimport SelectionArea, {SelectionEvents} from '@vanilla/index';\r\nimport {SelectionOptions} from '@vanilla/types';\r\nimport {defineComponent, PropType} from 'vue';\r\nexport * from '@vanilla/types';\r\nexport {default as VanillaSelectionArea} from '@vanilla/index';\r\n\r\nexport default defineComponent({\r\n    props: {\r\n        onBeforeStart: {type: Function, default: undefined},\r\n        onStart: {type: Function, default: undefined},\r\n        onMove: {type: Function, default: undefined},\r\n        onStop: {type: Function, default: undefined},\r\n        options: {\r\n            type: Object as PropType<Omit<SelectionOptions, 'boundaries'>>,\r\n            default: () => ({})\r\n        }\r\n    },\r\n\r\n    setup(): {instance: SelectionArea | null} {\r\n        return {\r\n            instance: null\r\n        };\r\n    },\r\n\r\n    mounted() {\r\n        this.instance = new SelectionArea({\r\n            boundaries: this.$refs.container as HTMLDivElement,\r\n            ...this.options\r\n        });\r\n\r\n        const {onBeforeStart, onStart, onMove, onStop} = this;\r\n        onBeforeStart && this.instance.on('beforestart', onBeforeStart as SelectionEvents['beforestart']);\r\n        onStart && this.instance.on('start', onStart as SelectionEvents['start']);\r\n        onMove && this.instance.on('move', onMove as SelectionEvents['move']);\r\n        onStop && this.instance.on('stop', onStop as SelectionEvents['stop']);\r\n\r\n        // this.instance.on('beforestart', args => {\r\n        //     this.$emit('beforestart', args);\r\n        //     return true;\r\n        // });\r\n        //\r\n        // this.instance.on('start', args => this.$emit('start', args));\r\n        // this.instance.on('move', args => this.$emit('move', args));\r\n        // this.instance.on('stop', args => this.$emit('stop', args));\r\n    },\r\n\r\n    beforeUnmount() {\r\n        this.instance?.destroy();\r\n    }\r\n});\r\n\r\n</script>\r\n", "<template>\r\n    <div ref=\"container\">\r\n        <slot/>\r\n    </div>\r\n</template>\r\n\r\n<script lang=\"ts\">\r\nimport SelectionArea, {SelectionEvents} from '@vanilla/index';\r\nimport {SelectionOptions} from '@vanilla/types';\r\nimport {defineComponent, PropType} from 'vue';\r\nexport * from '@vanilla/types';\r\nexport {default as VanillaSelectionArea} from '@vanilla/index';\r\n\r\nexport default defineComponent({\r\n    props: {\r\n        onBeforeStart: {type: Function, default: undefined},\r\n        onStart: {type: Function, default: undefined},\r\n        onMove: {type: Function, default: undefined},\r\n        onStop: {type: Function, default: undefined},\r\n        options: {\r\n            type: Object as PropType<Omit<SelectionOptions, 'boundaries'>>,\r\n            default: () => ({})\r\n        }\r\n    },\r\n\r\n    setup(): {instance: SelectionArea | null} {\r\n        return {\r\n            instance: null\r\n        };\r\n    },\r\n\r\n    mounted() {\r\n        this.instance = new SelectionArea({\r\n            boundaries: this.$refs.container as HTMLDivElement,\r\n            ...this.options\r\n        });\r\n\r\n        const {onBeforeStart, onStart, onMove, onStop} = this;\r\n        onBeforeStart && this.instance.on('beforestart', onBeforeStart as SelectionEvents['beforestart']);\r\n        onStart && this.instance.on('start', onStart as SelectionEvents['start']);\r\n        onMove && this.instance.on('move', onMove as SelectionEvents['move']);\r\n        onStop && this.instance.on('stop', onStop as SelectionEvents['stop']);\r\n\r\n        // this.instance.on('beforestart', args => {\r\n        //     this.$emit('beforestart', args);\r\n        //     return true;\r\n        // });\r\n        //\r\n        // this.instance.on('start', args => this.$emit('start', args));\r\n        // this.instance.on('move', args => this.$emit('move', args));\r\n        // this.instance.on('stop', args => this.$emit('stop', args));\r\n    },\r\n\r\n    beforeUnmount() {\r\n        this.instance?.destroy();\r\n    }\r\n});\r\n\r\n</script>\r\n", "import d from \"./node_modules/@viselect/vue/lib/viselect.esm.js\";export default d;\nexport * from \"./node_modules/@viselect/vue/lib/viselect.esm.js\""],
  "mappings": "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",
  "names": []
}
