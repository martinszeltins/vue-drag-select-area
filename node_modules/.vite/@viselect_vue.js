import {
  createBlock,
  defineComponent,
  openBlock,
  renderSlot
} from "./chunk-NHDK56GT.js";

// node_modules/@viselect/vue/lib/viselect.esm.js
var o = (t, e = "px") => typeof t == "number" ? t + e : t;
function n({ style: t }, e, s) {
  if (typeof e == "object")
    for (const [s2, i] of Object.entries(e))
      t[s2] = o(i);
  else
    s !== void 0 && (t[e] = o(s));
}
function r(t) {
  return (e, s, i, o2 = {}) => {
    e instanceof HTMLCollection || e instanceof NodeList ? e = Array.from(e) : Array.isArray(e) || (e = [e]), Array.isArray(s) || (s = [s]);
    for (const n2 of e)
      for (const e2 of s)
        n2[t](e2, i, { capture: false, ...o2 });
    return [e, s, i, o2];
  };
}
var h = r("addEventListener");
var c = r("removeEventListener");
var a = (t) => {
  const e = t.touches && t.touches[0] || t;
  return { tap: e, x: e.clientX, y: e.clientY, target: e.target };
};
function l(t) {
  let e = t.path || t.composedPath && t.composedPath();
  if (e)
    return e;
  let s = t.target.parentElement;
  for (e = [t.target, s]; s = s.parentElement; )
    e.push(s);
  return e.push(document, window), e;
}
function u(t, e, s = "touch") {
  switch (s) {
    case "center": {
      const s2 = e.left + e.width / 2, i = e.top + e.height / 2;
      return s2 >= t.left && s2 <= t.right && i >= t.top && i <= t.bottom;
    }
    case "cover":
      return e.left >= t.left && e.top >= t.top && e.right <= t.right && e.bottom <= t.bottom;
    case "touch":
      return t.right >= e.left && t.left <= e.right && t.bottom >= e.top && t.top <= e.bottom;
    default:
      throw new Error(`Unkown intersection mode: ${s}`);
  }
}
function d(t, e) {
  const s = t.indexOf(e);
  ~s && t.splice(s, 1);
}
function p(t, e = document) {
  const s = Array.isArray(t) ? t : [t], i = [];
  for (let t2 = 0, o2 = s.length; t2 < o2; t2++) {
    const o3 = s[t2];
    typeof o3 == "string" ? i.push(...Array.from(e.querySelectorAll(o3))) : o3 instanceof HTMLElement && i.push(o3);
  }
  return i;
}
var f = () => window.matchMedia("(hover: none), (pointer: coarse)").matches;
var m = (t, e) => {
  for (const [s, i] of Object.entries(t)) {
    const o2 = e[s];
    t[s] = o2 === void 0 ? t[s] : typeof o2 != "object" || typeof i != "object" || i === null || Array.isArray(i) ? o2 : m(i, o2);
  }
  return t;
};
var { abs: v, max: y, min: g, ceil: _ } = Math;
var SelectionArea = class extends class {
  constructor() {
    this.t = new Map(), this.on = this.addEventListener, this.off = this.removeEventListener, this.emit = this.dispatchEvent;
  }
  addEventListener(t, e) {
    const s = this.t.get(t) || new Set();
    return this.t.set(t, s), s.add(e), this;
  }
  removeEventListener(t, e) {
    return this.t.get(t)?.delete(e), this;
  }
  dispatchEvent(t, ...e) {
    let s = true;
    for (const i of this.t.get(t) || [])
      s = i(...e) !== false && s;
    return s;
  }
  unbindAllListeners() {
    this.t.clear();
  }
} {
  constructor(t) {
    super(), this.i = { touched: [], stored: [], selected: [], changed: { added: [], removed: [] } }, this.o = [], this.h = new DOMRect(), this.l = { y1: 0, x2: 0, y2: 0, x1: 0 }, this.u = true, this.p = true, this.m = { x: 0, y: 0 }, this.v = { x: 0, y: 0 }, this.disable = this.g.bind(this, false), this.enable = this.g, this._ = m({ selectionAreaClass: "selection-area", selectionContainerClass: void 0, selectables: [], document: window.document, behaviour: { overlap: "invert", intersect: "touch", startThreshold: { x: 10, y: 10 }, scrolling: { speedDivider: 10, manualSpeed: 750 } }, features: { range: true, touch: true, singleTap: { allow: true, intersect: "native" } }, startAreas: ["html"], boundaries: ["html"], container: "body" }, t);
    for (const t2 of Object.getOwnPropertyNames(Object.getPrototypeOf(this)))
      typeof this[t2] == "function" && (this[t2] = this[t2].bind(this));
    const { document: e, selectionAreaClass: s, selectionContainerClass: i } = this._;
    this.S = e.createElement("div"), this.A = e.createElement("div"), this.A.appendChild(this.S), this.S.classList.add(s), i && this.A.classList.add(i), n(this.S, { willChange: "top, left, bottom, right, width, height", top: 0, left: 0, position: "fixed" }), n(this.A, { overflow: "hidden", position: "fixed", transform: "translate3d(0, 0, 0)", pointerEvents: "none", zIndex: "1" }), this.enable();
  }
  g(t = true) {
    const { document: e, features: s } = this._, i = t ? h : c;
    i(e, "mousedown", this.T), s.touch && i(e, "touchstart", this.T, { passive: false });
  }
  T(t, e = false) {
    const { x: s, y: i, target: o2 } = a(t), { _: n2 } = this, { document: r2 } = this._, c2 = o2.getBoundingClientRect(), d2 = p(n2.startAreas, n2.document), f2 = p(n2.boundaries, n2.document);
    this.L = f2.find((t2) => u(t2.getBoundingClientRect(), c2));
    const m2 = l(t);
    if (!this.L || !d2.find((t2) => m2.includes(t2)) || !f2.find((t2) => m2.includes(t2)))
      return;
    if (!e && this.j("beforestart", t) === false)
      return;
    this.l = { x1: s, y1: i, x2: 0, y2: 0 };
    const v2 = r2.scrollingElement || r2.body;
    this.v = { x: v2.scrollLeft, y: v2.scrollTop }, this.u = true, this.clearSelection(false), h(r2, ["touchmove", "mousemove"], this.C, { passive: false }), h(r2, ["mouseup", "touchcancel", "touchend"], this.M), h(r2, "scroll", this.k);
  }
  F(t) {
    const { singleTap: { intersect: e }, range: s } = this._.features, i = a(t);
    let o2 = null;
    if (e === "native")
      o2 = i.target;
    else if (e === "touch") {
      this.resolveSelectables();
      const { x: t2, y: e2 } = i;
      o2 = this.o.find((s2) => {
        const { right: i2, left: o3, top: n3, bottom: r2 } = s2.getBoundingClientRect();
        return t2 < i2 && t2 > o3 && e2 < r2 && e2 > n3;
      });
    }
    if (!o2)
      return;
    for (this.resolveSelectables(); !this.o.includes(o2); ) {
      if (!o2.parentElement)
        return;
      o2 = o2.parentElement;
    }
    const { stored: n2 } = this.i;
    if (this.j("start", t), t.shiftKey && n2.length && s) {
      const t2 = n2[0], [e2, s2] = 4 & t2.compareDocumentPosition(o2) ? [o2, t2] : [t2, o2], i2 = [...this.o.filter((t3) => 4 & t3.compareDocumentPosition(e2) && 2 & t3.compareDocumentPosition(s2)), o2, e2, s2];
      this.select(i2);
    } else
      n2.includes(o2) && (n2.length === 1 || t.ctrlKey) ? this.deselect(o2) : this.select(o2);
    this.j("stop", t);
  }
  C(t) {
    const { container: e, document: s, features: i, behaviour: { startThreshold: o2 } } = this._, { x1: r2, y1: l2 } = this.l, { x: u2, y: d2 } = a(t), m2 = typeof o2;
    (m2 === "number" && v(u2 + d2 - (r2 + l2)) >= o2 || m2 === "object" && v(u2 - r2) >= o2.x || v(d2 - l2) >= o2.y) && (c(s, ["mousemove", "touchmove"], this.C, { passive: false }), h(s, ["mousemove", "touchmove"], this.O, { passive: false }), n(this.S, "display", "block"), p(e, s)[0].appendChild(this.A), this.resolveSelectables(), this.u = false, this.R = this.L.getBoundingClientRect(), this.p = this.L.scrollHeight !== this.L.clientHeight || this.L.scrollWidth !== this.L.clientWidth, this.p && (h(s, "wheel", this.$, { passive: false }), this.o = this.o.filter((t2) => this.L.contains(t2))), this.D(), this.j("start", t), this.O(t)), i.touch && f() && t.preventDefault();
  }
  D() {
    const { A: t, L: e, S: s } = this, i = this.R = e.getBoundingClientRect();
    this.p ? (n(t, { top: i.top, left: i.left, width: i.width, height: i.height }), n(s, { marginTop: -i.top, marginLeft: -i.left })) : (n(t, { top: 0, left: 0, width: "100%", height: "100%" }), n(s, { marginTop: 0, marginLeft: 0 }));
  }
  O(t) {
    const { x: e, y: s } = a(t), { m: i, l: o2, _: n2 } = this, { features: r2 } = n2, { speedDivider: h2 } = n2.behaviour.scrolling, c2 = this.L;
    if (o2.x2 = e, o2.y2 = s, this.p && (i.y || i.x)) {
      const e2 = () => {
        if (!i.x && !i.y)
          return;
        const { scrollTop: s2, scrollLeft: n3 } = c2;
        i.y && (c2.scrollTop += _(i.y / h2), o2.y1 -= c2.scrollTop - s2), i.x && (c2.scrollLeft += _(i.x / h2), o2.x1 -= c2.scrollLeft - n3), this.H(), this.q(), this.j("move", t), this.B(), requestAnimationFrame(e2);
      };
      requestAnimationFrame(e2);
    } else
      this.H(), this.q(), this.j("move", t), this.B();
    r2.touch && f() && t.preventDefault();
  }
  k() {
    const { v: t, _: { document: e } } = this, { scrollTop: s, scrollLeft: i } = e.scrollingElement || e.body;
    this.l.x1 += t.x - i, this.l.y1 += t.y - s, t.x = i, t.y = s, this.D(), this.H(), this.q(), this.j("move", null), this.B();
  }
  $(t) {
    const { manualSpeed: e } = this._.behaviour.scrolling, s = t.deltaY ? t.deltaY > 0 ? 1 : -1 : 0, i = t.deltaX ? t.deltaX > 0 ? 1 : -1 : 0;
    this.m.y += s * e, this.m.x += i * e, this.O(t), t.preventDefault();
  }
  H() {
    const { m: t, l: e, h: s, L: i, R: o2 } = this, { scrollTop: n2, scrollHeight: r2, clientHeight: h2, scrollLeft: c2, scrollWidth: a2, clientWidth: l2 } = i, u2 = o2, { x1: d2, y1: p2 } = e;
    let { x2: f2, y2: m2 } = e;
    f2 < u2.left ? (t.x = c2 ? -v(u2.left - f2) : 0, f2 = u2.left) : f2 > u2.right ? (t.x = a2 - c2 - l2 ? v(u2.left + u2.width - f2) : 0, f2 = u2.right) : t.x = 0, m2 < u2.top ? (t.y = n2 ? -v(u2.top - m2) : 0, m2 = u2.top) : m2 > u2.bottom ? (t.y = r2 - n2 - h2 ? v(u2.top + u2.height - m2) : 0, m2 = u2.bottom) : t.y = 0;
    const _2 = g(d2, f2), S2 = g(p2, m2), b2 = y(d2, f2), x = y(p2, m2);
    s.x = _2, s.y = S2, s.width = b2 - _2, s.height = x - S2;
  }
  B() {
    const { x: t, y: e, width: s, height: i } = this.h, { style: o2 } = this.S;
    o2.left = `${t}px`, o2.top = `${e}px`, o2.width = `${s}px`, o2.height = `${i}px`;
  }
  M(t, e) {
    const { document: s, features: i } = this._, { u: o2 } = this;
    c(s, ["mousemove", "touchmove"], this.C), c(s, ["touchmove", "mousemove"], this.O), c(s, ["mouseup", "touchcancel", "touchend"], this.M), c(s, "scroll", this.k), t && o2 && i.singleTap.allow ? this.F(t) : o2 || e || (this.q(), this.j("stop", t)), this.m.x = 0, this.m.y = 0, this.p && c(s, "wheel", this.$, { passive: true }), this.A.remove(), n(this.S, "display", "none"), this.U();
  }
  q() {
    const { o: t, _: e, i: s, h: i } = this, { stored: o2, selected: n2, touched: r2 } = s, { intersect: h2, overlap: c2 } = e.behaviour, a2 = [], l2 = [], d2 = [];
    for (let e2 = 0; e2 < t.length; e2++) {
      const s2 = t[e2];
      if (u(i, s2.getBoundingClientRect(), h2)) {
        if (n2.includes(s2))
          o2.includes(s2) && !r2.includes(s2) && r2.push(s2);
        else {
          if (c2 === "invert" && o2.includes(s2)) {
            d2.push(s2);
            continue;
          }
          l2.push(s2);
        }
        a2.push(s2);
      }
    }
    c2 === "invert" && l2.push(...o2.filter((t2) => !n2.includes(t2)));
    for (let t2 = 0; t2 < n2.length; t2++) {
      const e2 = n2[t2];
      a2.includes(e2) || c2 === "keep" && o2.includes(e2) || d2.push(e2);
    }
    s.selected = a2, s.changed = { added: l2, removed: d2 };
  }
  j(t, e) {
    return this.emit(t, { event: e, store: this.i, selection: this });
  }
  U() {
    const { _: t, i: e } = this, { selected: s, changed: i, touched: o2, stored: n2 } = e, r2 = s.filter((t2) => !n2.includes(t2));
    switch (t.behaviour.overlap) {
      case "drop":
        e.stored = r2.concat(n2.filter((t2) => !o2.includes(t2)));
        break;
      case "invert":
        e.stored = r2.concat(n2.filter((t2) => !i.removed.includes(t2)));
        break;
      case "keep":
        e.stored = n2.concat(s.filter((t2) => !n2.includes(t2)));
    }
  }
  trigger(t, e = true) {
    this.T(t, e);
  }
  resolveSelectables() {
    this.o = p(this._.selectables, this._.document);
  }
  clearSelection(t = true) {
    this.i = { stored: t ? [] : this.i.stored, selected: [], touched: [], changed: { added: [], removed: [] } };
  }
  getSelection() {
    return this.i.stored;
  }
  getSelectionArea() {
    return this.S;
  }
  cancel(t = false) {
    this.M(null, !t);
  }
  destroy() {
    this.cancel(), this.disable(), this.A.remove(), super.unbindAllListeners();
  }
  select(t, e = false) {
    const { changed: s, selected: i, stored: o2 } = this.i, n2 = p(t, this._.document).filter((t2) => !i.includes(t2) && !o2.includes(t2));
    return i.push(...n2), s.added.push(...n2), !e && this.j("move", null), n2;
  }
  deselect(t, e = false) {
    const { selected: s, stored: i, changed: o2 } = this.i;
    return !(!s.includes(t) && !i.includes(t)) && (o2.removed.push(t), d(i, t), d(s, t), !e && this.j("move", null), true);
  }
};
SelectionArea.version = "3.0.0-beta.7";
var S = defineComponent({ props: { onBeforeStart: { type: Function, default: void 0 }, onStart: { type: Function, default: void 0 }, onMove: { type: Function, default: void 0 }, onStop: { type: Function, default: void 0 }, options: { type: Object, default: () => ({}) } }, setup: () => ({ instance: null }), mounted() {
  this.instance = new SelectionArea({ boundaries: this.$refs.container, ...this.options });
  const { onBeforeStart: t, onStart: e, onMove: s, onStop: i } = this;
  t && this.instance.on("beforestart", t), e && this.instance.on("start", e), s && this.instance.on("move", s), i && this.instance.on("stop", i);
}, beforeUnmount() {
  this.instance?.destroy();
} });
var b = { ref: "container" };
S.render = function(t, o2, n2, r2, h2, c2) {
  return openBlock(), createBlock("div", b, [renderSlot(t.$slots, "default")], 512);
}, S.W = "src/SelectionArea.vue";
var viselect_esm_default = S;

// dep:@viselect_vue
var viselect_vue_default = viselect_esm_default;
export {
  SelectionArea as VanillaSelectionArea,
  viselect_vue_default as default
};
/*! @viselect/vue 3.0.0-beta.7 MIT | https://github.com/Simonwep/selection */
//# sourceMappingURL=@viselect_vue.js.map
